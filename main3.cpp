/**
 * @author Dylan Valerio
 * @date May 1, 2015
 * @description This file contains solutions to  PA3, Epipolar Geometry
 *              for Computer Vision Class (CS282).
 * 
 * @summary We implemented our solutions using OpenCV. The main class begins 
 * with reading the images, converting to gray scale and then equalizing the 
 *  histograms. Afterwards, we parse the given point matches for the two 
 *  images. We compute the fundamental matrix, Fgiven for this set, Pgiven. 
 * We plot the epipolar lines Egiven generated by Fgiven. Afterwards, we 
 * compute the residual of Pgiven of the right image and Egiven of the right 
 * image. We then use the matching algorithm of the previous programming 
 * assignment and compute for its point matches Ppa2, fundamental matrix Fpa2,
 *  and epipolar lines Epa2 and compare the two residuals.
 * We then parse the camera matrices of the first and second camera for use 
 * in triangulation, or the recovery of depth information. We use the 
 * triangulatePoints function of OpenCV and provide the camera matrices and 
 * Pgiven. We do the same triangulation method but for Ppa2. The recovered 
 * depth information was inputted in R to produce a visualization for analysis. 
 * We also compare the residuals taken from Pgiven against its corresponding 
 * 3D projection and likewise, Ppa2 against its own 3d projection.
 *For the visualization of the triangulation results, we have tried to 
 * use PCL and OpenGL, but turned to the rgl package of R for its simplicity.
 *
 * 
 * @build To build this, please use CMAKE. Simply run "cmake ." 
 * then "make all". The solution is divided into two classes, main3.cpp, 
 * and utils.cpp. The former is the bulk of PA3 while utils.cpp is the common 
 * code for both PA2 and PA3. Also included in the submission is PA2â€™s code, 
 * which is part of the CMAKE routine.
 */

#include "opencv2/highgui/highgui.hpp"
#include "opencv2/calib3d/calib3d.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <iostream> 
#include <sstream> 
#include <string>
#include "utils.cpp"
#include <limits>

using namespace cv;
using namespace std;

//typedef definitions for this script
typedef vector<Vec3f> Epilines;
typedef pair<Epilines, Epilines> PairEpilines;
typedef vector<Point3d> KeyPoints3d;

//method definitions
double pointLineDistance(Point2f line_start, Point2f line_end, Point2f point);
vector<Vec3f> getEpilines(KeyPoints keyPoints, Mat fundamentalMatrix);
PairEpilines plotEpilines(PairKeyPoints pairKeyPoints, Mat img1, Mat img2,
        Mat fundamentalMatrix);
void plotMatches(KeyPoints leftMatches, KeyPoints rightMatches, Mat img1, Mat img2);
Mat readFile(ifstream& file);
void writeProjectiveTriangulatedMatToFile(string file_name, Mat m);
double homogenous2DToProjected3DDistance(KeyPoints points2d, Mat points3d);
double computeResidual(KeyPoints kp, Epilines epi, int sizeOfImage);
Mat triangulatedToEuclidean(Mat t);

/** @function main */
int main(int argc, char** argv) {
    /// Load source image and convert it to gray
    Mat src1 = imread(argv[1], CV_LOAD_IMAGE_GRAYSCALE);
    Mat src2 = imread(argv[2], CV_LOAD_IMAGE_GRAYSCALE);
    Mat img1, img2;
    equalizeHist(src1, img1);
    equalizeHist(src2, img2);

    //load matches file
    ifstream file(argv[3]);
    Mat matches = readFile(file);

    //get the first two columns as left keypoints
    Mat leftKeypoints = Mat(matches, Rect(0, 0, 2, matches.rows));
    //get the first two columns as right keypoints        
    Mat rightKeypoints = Mat(matches, Rect(2, 0, 2, matches.rows));

    //convert matches for the fundamental matrix
    KeyPoints selPointsLeft, selPointsRight;
    for (int j = 0; j < leftKeypoints.rows; j++) {
        Point2f leftPoint = Point2f(leftKeypoints.at<double>(j, 0),
                leftKeypoints.at<double>(j, 1));
        selPointsLeft.push_back(leftPoint);
        Point2f rightPoint = Point2f(rightKeypoints.at<double>(j, 0),
                rightKeypoints.at<double>(j, 1));
        selPointsRight.push_back(rightPoint);
    }

    //plotting the matches for checking
    plotMatches(selPointsLeft, selPointsRight, img1, img2);

    //get the fundamental matrix
    Mat mask;
    Mat givenFundamentalMatrix = findFundamentalMat(
            selPointsLeft, selPointsRight, mask, CV_FM_8POINT);

    //get and plot the epipolar lines
    PairEpilines pairEpilines = plotEpilines(pair<KeyPoints, KeyPoints>(
            selPointsLeft, selPointsRight), img1.clone(), img2.clone(),
            givenFundamentalMatrix);
    Epilines leftEpilines = pairEpilines.first;
    Epilines rightEpilines = pairEpilines.second;

    //show residuals between the points of the second image to the 
    //corresponding epi lines. I'm assuming this is right point to right epiline
    double residual = computeResidual(selPointsRight, rightEpilines, img2.cols);
    cout << "Given right keypoints to right epilines residual: " << residual << endl;

    //Now fit a fundamental matrix based on putative 
    //correspondences obtained by your code from Program-
    //ming Assignment 2. Because the set of putative matches 
    //includes outliers, you will need to use RANSAC.
    //For this part, use only the normalized fitting approach.
    Coordinates coords1 = extractFeaturePoints(img1, 120);
    Coordinates coords2 = extractFeaturePoints(img1, 120);

    //get feature descriptors
    Patches patches1 = extractPatches(coords1, img1);
    Patches patches2 = extractPatches(coords2, img2);

    //get feature matches
    PairKeyPoints keypoints = getKeyPoints(coords1, coords2, img1,
            img2, 80, 20);
    //get another fundamental matrix
    Mat pa2OutputMask;
    Mat pa2LeftMat = Mat(keypoints.first);
    Mat pa2RightMat = Mat(keypoints.second);
    Mat pa2FundamentalMatrix = findFundamentalMat(
            pa2LeftMat, pa2RightMat, pa2OutputMask, FM_RANSAC);

    //get a new set of key points based on the RANSAC result
    KeyPoints leftInliers, rightInliers;
    for (int i = 0; i < pa2OutputMask.rows; i++) {
        bool isInlier = (unsigned int) pa2OutputMask.at<uchar>(i) ? true : false;
        if (isInlier) {
            Point2f left = keypoints.first[i];
            Point2f right = keypoints.second[i];
            leftInliers.push_back(left);
            rightInliers.push_back(right);
        }
    }

    //plotting the produced matches for checking
    plotMatches(leftInliers, rightInliers, img1, img2);

    //get and plot matches from PA2
    PairEpilines pa2Epilines = plotEpilines(pair<KeyPoints, KeyPoints>(
            leftInliers, rightInliers), img1.clone(), img2.clone(),
            pa2FundamentalMatrix);

    //get PA2's residuals
    double pa2Residual = computeResidual(leftInliers, pa2Epilines.second, img2.cols);
    cout << "PA2 right keypoints to right epilines residual: " << pa2Residual << endl;

    //load the camera matrices
    ifstream camera_file_1(argv[4]);
    ifstream camera_file_2(argv[5]);
    Mat camera_1 = readFile(camera_file_1);
    Mat camera_2 = readFile(camera_file_2);

    //getting the camera centers
    printf("Left camera center: (%f, %f)\n",
            camera_1.at<float>(0, 3), camera_1.at<float>(1, 3));
    printf("Right camera center: (%f, %f)\n",
            camera_2.at<float>(0, 3), camera_2.at<float>(1, 3));

    //triangulate the points using the two cameras
    //use the first pair
    Mat givenPoints4D;
    triangulatePoints(camera_1, camera_2, selPointsLeft, selPointsRight,
            givenPoints4D);
    //print out first pixel coordinates for debugging
    //    cout << givenPoints4D.at<Point>(0, 0) << endl;

    //tried to use PCL, but failed. It's in the trash_code.txt file
    //also tried using OpenGL but the results do not make sense

    //write to file for R visualization
    string file_name = argv[6];
    Mat givenProjective = triangulatedToEuclidean(givenPoints4D);
    writeProjectiveTriangulatedMatToFile(file_name, givenProjective);

    //compute residual of true matches
    double leftGivenResidual = homogenous2DToProjected3DDistance(selPointsLeft,
            givenPoints4D);
    double rightGivenResidual = homogenous2DToProjected3DDistance(selPointsRight,
            givenPoints4D);
    cout << "Left given residual: " << leftGivenResidual << endl;
    cout << "Right given residual: " << rightGivenResidual << endl;

    //then get triangulation for my PA2 matches
    Mat paPoints4D;
    triangulatePoints(camera_1, camera_2, leftInliers, rightInliers, paPoints4D);

    //write to file for R visualization
    string file_name_for_pa2 = argv[7];
    writeProjectiveTriangulatedMatToFile(file_name_for_pa2,
            triangulatedToEuclidean(paPoints4D));

    //compute residual for my PA2 matches
    //compute residual of true matches
    double leftPa2Residual = homogenous2DToProjected3DDistance(leftInliers,
            paPoints4D);
    double rightPa2Residual = homogenous2DToProjected3DDistance(rightInliers,
            paPoints4D);
    cout << "Left pa2 residual: " << leftPa2Residual << endl;
    cout << "Right pa2 residual: " << rightPa2Residual << endl;

    return 0;
}

double computeResidual(KeyPoints kp, Epilines epi, int sizeOfImage) {
    double residualAggregate = 0;
    for (int i = 0; i < kp.size(); i++) {
        Point2f start = Point2f(0, -(epi[i])[2] / (epi[i])[1]);
        Point2f end = Point2f(sizeOfImage, -((epi[i])[2]+
                (epi[i])[0] * sizeOfImage) / (epi[i])[1]);
        residualAggregate += pointLineDistance(start, end, kp[i]);
    }
    return residualAggregate / kp.size();
}

/**
 * Translated the triangulated points (homogenous) to euclidean (projective)
 * @param t
 * @return 
 */
Mat triangulatedToEuclidean(Mat t) {
    Mat points3dTransposed;
    transpose(t, points3dTransposed);
    Mat euclidean;
    convertPointsFromHomogeneous(points3dTransposed, euclidean);
    return euclidean;
}

/**
 * Computation of 2d point residual to 3d:
 * 2d becomes (x,y,1) while 3d (homogenous) becomes (x/a,y/a,z/a)
 * @param points2d
 * @param points3d
 * @return 
 */
double homogenous2DToProjected3DDistance(KeyPoints points2d, Mat points3d) {
    Mat euclidean = triangulatedToEuclidean(points3d);
    double residualAgg = 0.0;
    for (int i = 0; i < euclidean.rows; i++) {
        Point3d p = Point3d(euclidean.at<float>(i, 0), euclidean.at<float>(i, 1),
                euclidean.at<float>(i, 2));
        Point3d q = Point3d(points2d[i].x, points2d[i].y, 1);
        residualAgg += norm(Mat(p), Mat(q));
    }
    return residualAgg / points2d.size();
}

void writeProjectiveTriangulatedMatToFile(string file_name, Mat m) {
    ofstream output_file;
    output_file.open(file_name);

    for (int i = 0; i < m.rows; i++) {
        Vec3f vec = m.at<Vec3f>(i);
        output_file << vec[0] << ",";
        output_file << vec[1] << ",";
        output_file << vec[2] << endl;
    }
    output_file.close();
}

Mat readFile(ifstream& file) {
    int rows = 0;
    string line;
    Mat mat;
    if (file.is_open()) {
        double x;
        while (getline(file, line)) {
            std::istringstream in(line);
            while (in >> x) {
                mat.push_back(x);
            }
            rows++;
        }
        file.close();
    }
    mat = mat.reshape(1, rows);
    return mat;
}

Epilines getEpilines(KeyPoints keyPoints, Mat fundamentalMatrix) {
    //compute epipolar lines
    vector<Vec3f> epilines;
    computeCorrespondEpilines(keyPoints, 1, fundamentalMatrix, epilines);
    return epilines;
}

PairEpilines plotEpilines(PairKeyPoints pairKeyPoints, Mat img1, Mat img2,
        Mat fundamentalMatrix) {
    vector<Vec3f> rightEpilines = getEpilines(pairKeyPoints.first,
            fundamentalMatrix);
    vector<Vec3f> leftEpilines = getEpilines(pairKeyPoints.second,
            fundamentalMatrix);

    // for all epipolar lines
    for (vector<Vec3f>::const_iterator it = rightEpilines.begin();
            it != rightEpilines.end(); ++it) {
        // draw the epipolar line between first and last column
        line(img2, Point(0, -(*it)[2] / (*it)[1]),
                Point(img2.cols, -((*it)[2]+(*it)[0] * img2.cols) / (*it)[1]),
                Scalar(255, 255, 255));
    }
    for (vector<Vec3f>::const_iterator it = leftEpilines.begin();
            it != leftEpilines.end(); ++it) {
        // draw the epipolar line between first and last column
        line(img1, Point(0, -(*it)[2] / (*it)[1]),
                Point(img1.cols, -((*it)[2]+(*it)[0] * img1.cols) / (*it)[1]),
                Scalar(255, 255, 255));
    }

    // Display the images with points and epipolar lines
    Size img1Sz = img1.size();
    Size img2Sz = img2.size();
    int height = max(img1Sz.height, img2Sz.height);
    Mat plottedImg(height, img1Sz.width + img2Sz.width, img1.type());
    Mat left(plottedImg, Rect(0, 0, img1Sz.width, img1Sz.height));
    img1.copyTo(left);
    Mat right(plottedImg, Rect(img1Sz.width, 0, img2Sz.width, img2Sz.height));
    img2.copyTo(right);
    namedWindow("Epilines");
    imshow("Epilines", plottedImg);
    waitKey(0);

    return pair<vector<Vec3f>, vector < Vec3f >> (leftEpilines, rightEpilines);
}

double pointLineDistance(Point2f line_start, Point2f line_end, Point2f point) {
    double normalLength = norm(line_end - line_start);
    double distance = (double) ((point.x - line_start.x) *
            (line_end.y - line_start.y) - (point.y - line_start.y) *
            (line_end.x - line_start.x)) / normalLength;
    return abs(distance);
}

void plotMatches(KeyPoints leftMatches, KeyPoints rightMatches, Mat img1, Mat img2) {
    //create combination matrix
    Size img1Sz = img1.size();
    Size img2Sz = img2.size();
    int height = max(img1Sz.height, img2Sz.height);
    Mat plottedImg(height, img1Sz.width + img2Sz.width, img1.type());
    //    Mat plottedImg(height * 2, img1Sz.width + img2Sz.width, img1.type());
    Mat left(plottedImg, Rect(0, 0, img1Sz.width, img1Sz.height));
    img1.copyTo(left);
    Mat right(plottedImg, Rect(img1Sz.width, 0, img2Sz.width, img2Sz.height));
    img2.copyTo(right);

    //draw the matches
    for (int i = 0; i < leftMatches.size(); i++) {
        Point pointOfLeftImg = leftMatches[i];
        //offset for the first image
        Point pointOfRightImg = Point(rightMatches[i].x + img1.cols,
                rightMatches[i].y);
        line(plottedImg, pointOfLeftImg, pointOfRightImg, Scalar(0, 0, 255), 1);
        circle(plottedImg, pointOfLeftImg, 5, Scalar(0), 2, 8, 0);
        circle(plottedImg, pointOfRightImg, 5, Scalar(0), 2, 8, 0);
    }
    namedWindow("Matches", CV_WINDOW_AUTOSIZE);
    imshow("Matches", plottedImg);
    waitKey(0);
}

